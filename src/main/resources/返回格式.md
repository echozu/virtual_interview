# API 返回结果类使用指南与实例

## 1. 基础返回类结构

```java
/**
 * 通用返回类
 * @param <T> 返回数据类型
 */
public class BaseResponse<T> {
    private int code;       // 状态码
    private T data;         // 返回数据
    private String message; // 返回消息

    // 构造方法等...
}
```

## 2. 成功返回示例

### 2.1 返回简单字符串

```java
@GetMapping("/simple")
public BaseResponse<String> getSimpleMessage() {
    return ResultUtils.success("操作成功");
}
```

**返回结果**：
```json
{
  "code": 0,
  "data": "操作成功",
  "message": "ok"
}
```

### 2.2 返回对象数据

```java
@GetMapping("/user/{id}")
public BaseResponse<User> getUser(@PathVariable Long id) {
    User user = userService.getById(id);
    return ResultUtils.success(user);
}
```

**返回结果**：
```json
{
  "code": 0,
  "data": {
    "id": 123,
    "name": "张三",
    "email": "zhangsan@example.com"
  },
  "message": "ok"
}
```

### 2.3 返回列表数据

```java
@GetMapping("/users")
public BaseResponse<List<User>> getUserList() {
    List<User> users = userService.list();
    return ResultUtils.success(users);
}
```

**返回结果**：
```json
{
  "code": 0,
  "data": [
    {"id": 1, "name": "张三"},
    {"id": 2, "name": "李四"}
  ],
  "message": "ok"
}
```

### 2.4 返回分页数据

```java
@GetMapping("/users/page")
public BaseResponse<Page<User>> getUserPage(@RequestParam int current, 
                                          @RequestParam int size) {
    Page<User> page = userService.page(new Page<>(current, size));
    return ResultUtils.success(page);
}
```

**返回结果**：
```json
{
  "code": 0,
  "data": {
    "records": [
      {"id": 1, "name": "张三"},
      {"id": 2, "name": "李四"}
    ],
    "total": 15,
    "size": 2,
    "current": 1,
    "pages": 8
  },
  "message": "ok"
}
```

## 3. 错误返回示例

### 3.1 参数验证失败

```java
@PostMapping("/register")
public BaseResponse<String> register(@Valid @RequestBody RegisterDTO dto) {
    if (userService.existsByEmail(dto.getEmail())) {
        return ResultUtils.error(ErrorCode.PARAMS_ERROR, "邮箱已存在");
    }
    // 注册逻辑...
    return ResultUtils.success("注册成功");
}
```

**返回结果**：
```json
{
  "code": 40000,
  "data": null,
  "message": "邮箱已存在"
}
```

### 3.2 权限不足

```java
@DeleteMapping("/user/{id}")
public BaseResponse<String> deleteUser(@PathVariable Long id) {
    if (!currentUser.isAdmin()) {
        return ResultUtils.error(ErrorCode.NO_AUTH_ERROR);
    }
    userService.removeById(id);
    return ResultUtils.success("删除成功");
}
```

**返回结果**：
```json
{
  "code": 40101,
  "data": null,
  "message": "无权限"
}
```

### 3.3 资源不存在

```java
@GetMapping("/article/{id}")
public BaseResponse<Article> getArticle(@PathVariable Long id) {
    Article article = articleService.getById(id);
    if (article == null) {
        return ResultUtils.error(ErrorCode.NOT_FOUND_ERROR, "文章不存在");
    }
    return ResultUtils.success(article);
}
```

**返回结果**：
```json
{
  "code": 40400,
  "data": null,
  "message": "文章不存在"
}
```

### 3.4 系统异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public BaseResponse<String> handleException(Exception e) {
        log.error("系统异常", e);
        return ResultUtils.error(ErrorCode.SYSTEM_ERROR, "系统繁忙");
    }
    
    @ExceptionHandler(BusinessException.class)
    public BaseResponse<String> handleBusinessException(BusinessException e) {
        return ResultUtils.error(e.getCode(), e.getMessage());
    }
}
```

**返回结果**：
```json
{
  "code": 50000,
  "data": null,
  "message": "系统繁忙"
}
```

## 4. 复杂业务场景示例

### 4.1 批量操作部分成功

```java
@PostMapping("/batchDelete")
public BaseResponse<BatchResult> batchDelete(@RequestBody List<Long> ids) {
    BatchResult result = new BatchResult();
    for (Long id : ids) {
        try {
            userService.removeById(id);
            result.addSuccess(id);
        } catch (Exception e) {
            result.addFailed(id, e.getMessage());
        }
    }
    return ResultUtils.success(result);
}
```

**返回结果**：
```json
{
  "code": 0,
  "data": {
    "successCount": 3,
    "failedCount": 1,
    "failedItems": [
      {
        "id": 4,
        "reason": "用户不存在"
      }
    ]
  },
  "message": "ok"
}
```

### 4.2 带警告的成功操作

```java
@PostMapping("/updatePassword")
public BaseResponse<PasswordUpdateResult> updatePassword(@RequestBody PasswordDTO dto) {
    PasswordUpdateResult result = userService.updatePassword(dto);
    if (result.isWeakPassword()) {
        return ResultUtils.successWithWarning(result, "密码强度较弱，建议修改");
    }
    return ResultUtils.success(result);
}
```

**返回结果**（带警告）：
```json
{
  "code": 0,
  "data": {
    "updated": true,
    "weakPassword": true
  },
  "message": "密码强度较弱，建议修改"
}
```

## 5. 最佳实践建议

1. **Controller层**：
    - 所有方法返回`BaseResponse<T>`
    - 使用`ResultUtils`构建返回对象
    - 业务异常抛出，由全局异常处理器处理

2. **Service层**：
    - 返回原始数据
    - 抛出业务异常`throw new BusinessException(ErrorCode.PARAMS_ERROR, "错误描述")`

3. **错误处理**：
   ```java
   // 自定义业务异常
   public class BusinessException extends RuntimeException {
       private final int code;
       
       public BusinessException(ErrorCode errorCode) {
           super(errorCode.getMessage());
           this.code = errorCode.getCode();
       }
       
       // getter...
   }
   ```

4. **状态码使用原则**：
    - `0`：成功
    - `4xxxx`：客户端错误
    - `5xxxx`：服务端错误
    - `40xxx`：参数/验证错误
    - `41xxx`：认证/授权错误
    - `50xxx`：系统/数据库错误

5. **前端协作建议**：
   ```javascript
   // 响应拦截器示例
   axios.interceptors.response.use(response => {
     const res = response.data
     if (res.code !== 0) {
       // 处理业务错误
       if (res.code === 40100) {
         router.push('/login')
       }
       return Promise.reject(res)
     }
     return res.data
   }, error => {
     // 处理HTTP错误
     return Promise.reject(error)
   })
   ```

通过这种统一的返回格式，可以保证：
1. 前后端交互规范一致
2. 错误处理逻辑清晰
3. 便于监控和日志记录
4. 客户端可以统一处理各类响应